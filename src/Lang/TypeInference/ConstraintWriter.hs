module Lang.TypeInference.ConstraintWriter where


import           Lang.Syntax
import           Lang.TypeEnv                    as TypeEnv
import           Lang.TypeInference.Substitution
import           Lang.TypeInference.Type

import           Control.Applicative
import           Control.Monad.Except
import           Control.Monad.State

import           Data.Monoid

import           Control.Monad.Identity          (Identity)
import           Control.Monad.RWS               (RWST, ask, evalRWS, evalRWST,
                                                  local, tell)
import           Data.List                       (foldl')
import qualified Data.Map                        as Map
import qualified Data.Set                        as Set
import           Lang.Utils.Util

------------------------------------------------------------------------
--              Constraint Writer
------------------------------------------------------------------------

{-
        Module generating set of constraints, instantiating polymorphic types
        with fresh names so that no clashes occur and possibly rejecting some ill-typed expressions.
-}


-- |Monad encapsulating constraint generation logic.
type ConstraintWriter a = RWST
                            TypeEnv -- Constraints are generated within environment of already defined functions.
                                    -- It's actually really nice to keep it in ReaderMonad since
                                    -- we can introduce shadowing of variables easily by using local function.
                            [Constraint] -- WriterMonad                  -> holds set of constraints.
                            [String]     -- StateMonad's state           -> holds infinite supply of fresh names.
                            (Except TypeError) a -- State Monad's result -> We might detect some type errors in this stage.


------------------------------------------------------------------------
--              Interface
------------------------------------------------------------------------

-- | Infer type and constraints for given expression and type environment.
evalConstraintWriter :: Expr -> TypeEnv -> Either TypeError (Type, [Constraint])
evalConstraintWriter expr env = runExcept $
    evalRWST (writeConstraints expr) env freshNamesSupply

------------------------------------------------------------------------
--              Implementation
------------------------------------------------------------------------

-- |Constraintrs are generated by following rules of Hindley-Milner (HM).
-- We traverse AST infering types and writing constraints along the way.
writeConstraints :: Expr -> ConstraintWriter Type
writeConstraints expr =
    case expr of
        Var name -> do
            env <- ask
            case TypeEnv.lookup env name of
                Nothing     -> throwError $ UnboundVariable name
                Just schema -> instantiateScheme schema

        App e1 e2 -> do
            t1 <- writeConstraints e1
            t2 <- writeConstraints e2
            resultT <- freshType
            addConstraint (t1, t2 `TArr` resultT)
            return resultT

        Lam name expr -> do
            argT <- freshType
            res <- locally (name, emptyScheme argT) $ writeConstraints expr
            return (argT `TArr` res)

        Let name e1 e2 -> do
            t1 <- writeConstraints e1
            env <- ask
            let generalized = generalize env t1
            locally (name, generalized) $ writeConstraints e2

        Lit (LInt _)  -> return typeInt

        Lit (LBool _) -> return typeBool

        If condE trE flE -> do
            t1 <- writeConstraints condE
            t2 <- writeConstraints trE
            t3 <- writeConstraints flE
            addConstraint (t1, typeBool)
            addConstraint (t2, t3)
            return t2

        Fix e1 -> do
            t1 <- writeConstraints e1
            tv <- freshType
            addConstraint (tv `TArr` tv, t1)
            return tv

        Op binop e1 e2 -> do
            t1 <- writeConstraints e1
            t2 <- writeConstraints e2
            resT <- freshType
            let actual = t1 `TArr` t2 `TArr` resT
                expected = opType binop

            addConstraint (actual, expected)
            return resT

------------------------------------------------------------------------
-- Fresh Names Supply
------------------------------------------------------------------------

-- | Generate fresh type holding type variable.
freshType :: ConstraintWriter Type
freshType = do
    var <- freshTypeVar
    return $ TVar var

-- | Generate fresh type variable.
freshTypeVar :: ConstraintWriter TypeVar
freshTypeVar = do
    name <- freshName
    return $ TypeVar name

-- | Generate fresh name.
freshName :: ConstraintWriter String
freshName = do
    (name:others) <- get
    put others
    return name

-- | Generate substitution mapping list of type variables to fresh type variables.
freshTypeVars :: [TypeVar] -> ConstraintWriter Subsitution
freshTypeVars =
    flip foldM emptySubst $
        \acc e -> do
            var <- freshType
            return $ extendSubst e var acc

-- |In my opinion this is one of the best haskell oneliners :)
freshNamesSupply :: [String]
freshNamesSupply = [1..] >>= flip replicateM ['a'..'z']

------------------------------------------------------------------------
-- Utilities
------------------------------------------------------------------------

-- |Write constraint.
addConstraint :: (Type, Type) -> ConstraintWriter ()
addConstraint (t1,t2) = do tell [(t1, t2)]

-- |Execute action in locally extended type enivronment by given binding.
locally :: (String, TypeScheme) -> ConstraintWriter a -> ConstraintWriter a
locally (name, scheme) inf = do
    let trans env = TypeEnv.extend env name scheme
    local trans inf


-- |Create empty Type Scheme without forall quanitfier.
emptyScheme :: Type -> TypeScheme
emptyScheme var = Forall [] var

-- |Generalize type withing given environment.
--      Bind all free type variables in quantifier.
generalize :: TypeEnv -> Type -> TypeScheme
generalize tpEnv tpe = Forall vars tpe
    where vars = Set.toList $ ftv tpe `Set.difference` ftv tpEnv

-- |Instantiate Type Scheme's polymorphic types with fresh type variables.
--      Very important!
instantiateScheme :: TypeScheme -> ConstraintWriter Type
instantiateScheme (Forall vars tpe) = do
    map <- freshTypeVars vars
    return $ substitute map tpe

-- |Type for each binary operator.
opType :: BinOp -> Type
opType op = case op of
    Add -> intArrowIntArrowInt
    Sub -> intArrowIntArrowInt
    Mul -> intArrowIntArrowInt
    Eql -> intArrowIntArrowBool
    Lt  -> intArrowIntArrowBool
    Lte -> intArrowIntArrowBool
    Gt  -> intArrowIntArrowBool
    Gte -> intArrowIntArrowBool
    Or  -> boolArrowBoolArrowBool
    And -> boolArrowBoolArrowBool
    where intArrowIntArrowInt  = typeInt `TArr` typeInt `TArr` typeInt
          intArrowIntArrowBool = typeInt `TArr` typeInt `TArr` typeBool
          boolArrowBoolArrowBool = typeBool `TArr` typeBool `TArr` typeBool

------------------------------------------------------------------------
------------------------------------------------------------------------
